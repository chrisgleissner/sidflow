name: Nightly Performance Tests

on:
  schedule:
    # Run every night at 2:00 AM UTC
    - cron: '0 2 * * *'
  workflow_dispatch: # Allow manual trigger

jobs:
  performance:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: 1.3.1
      
      - name: Cache HVSC collection
        uses: actions/cache@v4
        with:
          path: |
            workspace/hvsc
            workspace/hvsc-version.json
          key: hvsc-${{ hashFiles('.sidflow.json') }}
          restore-keys: |
            hvsc-
      
      - name: Cache classified data
        uses: actions/cache@v4
        with:
          path: |
            data/classified
          key: classified-${{ hashFiles('data/classified/sample.jsonl') }}
          restore-keys: |
            classified-
      
      - name: Install dependencies
        run: bun install --frozen-lockfile
      
      - name: Install k6
        run: |
          K6_VERSION=0.52.0
          curl -fsSL "https://github.com/grafana/k6/releases/download/v${K6_VERSION}/k6-v${K6_VERSION}-linux-amd64.tar.gz" -o /tmp/k6.tar.gz
          tar -xzf /tmp/k6.tar.gz -C /tmp
          sudo install -m 0755 /tmp/k6-v${K6_VERSION}-linux-amd64/k6 /usr/local/bin/k6
          rm -rf /tmp/k6.tar.gz /tmp/k6-v${K6_VERSION}-linux-amd64
      
      - name: Build project
        run: bun run build
        env:
          SIDFLOW_SKIP_WASM_UPSTREAM_CHECK: '1'

      - name: Build web app
        run: cd packages/sidflow-web && npm run build

      - name: Prepare minimal perf fixtures (no HVSC download)
        run: bash scripts/perf/prepare-perf-fixtures.sh
      
      - name: Copy static assets for standalone server
        run: |
          cd packages/sidflow-web
          # Next.js standalone build requires manual copy of static assets
          cp -r .next/static .next/standalone/packages/sidflow-web/.next/static
          cp -r public .next/standalone/packages/sidflow-web/public
          echo "âœ“ Static assets copied to standalone build"
      
      - name: Install Playwright browsers
        run: cd packages/sidflow-web && npx playwright install chromium
      
      - name: Start web server
        run: |
          cd packages/sidflow-web
          # Use standalone server (npm start doesn't work with standalone output)
          # Point to repo root config file since standalone doesn't include it
          # NOTE: SIDFLOW_RELAXED_CSP=1 is required ONLY for CI/E2E testing environments to allow Next.js inline hydration scripts.
          # In CI, Playwright/E2E tests require relaxed CSP because Next.js standalone injects inline scripts for hydration,
          # which are blocked by strict CSP. Without this, React mounting fails and tests time out.
          # Production deployments SHOULD NOT set SIDFLOW_RELAXED_CSP=1; the default strict CSP is recommended for security.
          # Next.js standalone always runs with NODE_ENV=production internally, so this variable is only for test environments.
          # Ensure server-side WASM renderer can locate the binary in standalone mode.
          # Bind explicitly to loopback to keep health-check curls stable.
          SIDFLOW_LIBSIDPLAYFP_WASM_PATH="$PWD/public/wasm/libsidplayfp.wasm" \
          SIDFLOW_RELAXED_CSP=1 SIDFLOW_CONFIG="$PWD/../../.sidflow.json" \
          HOSTNAME="127.0.0.1" PORT="3000" \
          node .next/standalone/packages/sidflow-web/server.js > /tmp/perf-server.log 2>&1 &
          echo $! > /tmp/perf-server.pid
          
          # Wait for server to be ready with proper health check
          # Accept any response (200 or 503) since server may be degraded without full dependencies
          echo "Waiting for server to be ready..."
          for i in {1..60}; do
            if curl -s http://127.0.0.1:3000/api/health > /dev/null 2>&1; then
              echo "Server is ready after ${i} seconds"
              break
            fi
            if [ $i -eq 60 ]; then
              echo "ERROR: Server failed to start within 60 seconds"
              echo "=== Last 100 lines of server log ==="
              tail -n 100 /tmp/perf-server.log
              exit 1
            fi
            sleep 1
          done
          
          # Show last 20 lines of server log to confirm startup
          echo "=== Server startup (last 20 lines) ==="
          tail -n 20 /tmp/perf-server.log

      - name: Run unified performance runner (Playwright + k6)
        run: |
          echo "=== Starting performance tests ==="
          # NOTE: We test against standalone server directly rather than Docker container for performance.
          # Docker adds ~10s startup overhead and requires managing container lifecycle/volumes/networking.
          # Direct server approach is simpler, faster, and equally effective for performance measurement.
          # Docker-based integration testing is already covered by release workflow smoke tests.
          # Public GitHub runners are noisy and resource-constrained. Keep the CI profile intentionally small.
          # Remote/scale runs (hundreds of users) are supported via `--env remote --profile scale --enable-remote`,
          # but are intentionally not exercised here until Fly.io + Raspberry Pi targets exist and are stable.
          npm run perf:run -- --env ci --profile reduced --executor k6 --pacing 1 --base-url http://localhost:3000 --results performance/results --tmp performance/tmp --execute
          EXIT_CODE=$?
          
          # Always show server log excerpt after test run
          echo ""
          echo "=== Server activity during tests (last 50 lines) ==="
          tail -n 50 /tmp/perf-server.log || true
          
          exit $EXIT_CODE
        env:
          CI: true
          SIDFLOW_SKIP_WASM_UPSTREAM_CHECK: '1'
      
      - name: Stop web server
        if: always()
        run: |
          echo "=== Stopping web server ==="
          if [ -f /tmp/perf-server.pid ]; then
            kill $(cat /tmp/perf-server.pid) || true
          fi
          
          echo ""
          echo "=== Full server log (last 200 lines) ==="
          tail -n 200 /tmp/perf-server.log || true
      
      - name: Upload server logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: server-logs-${{ github.run_number }}
          path: /tmp/perf-server.log
          retention-days: 7
      
      - name: Upload performance metrics
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: performance-metrics-${{ github.run_number }}
          path: |
            performance/results/
            performance/tmp/
            packages/sidflow-web/playwright-report/
          retention-days: 30
      
      - name: Upload performance report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: performance-report-${{ github.run_number }}
          path: |
            performance/results/**/report.md
            performance/results/**/summary/summary.json
          retention-days: 90
      
      - name: Comment PR with performance results
        if: github.event_name == 'pull_request' && always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            
            // Find the latest performance report
            const perfDir = 'tmp/performance';
            const files = fs.readdirSync(perfDir).filter(f => f.endsWith('.md'));
            
            if (files.length > 0) {
              const latestReport = files.sort().reverse()[0];
              const reportPath = path.join(perfDir, latestReport);
              const report = fs.readFileSync(reportPath, 'utf8');
              
              // Truncate if too long for GitHub comment
              const maxLength = 65000;
              const truncatedReport = report.length > maxLength 
                ? report.substring(0, maxLength) + '\n\n... (truncated)'
                : report;
              
              await github.rest.issues.createComment({
                ...context.repo,
                issue_number: context.issue.number,
                body: `## ðŸš€ Performance Test Results\n\n${truncatedReport}`
              });
            }
