name: Release Packages

on:
  push:
    tags:
      - "*.*.*"
      - "v*.*.*"
  release:
    types: [published]
  workflow_dispatch:

jobs:
  release:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/${{ github.repository_owner }}/sidflow-ci:latest
    if: ${{ github.ref_type == 'tag' || github.event_name == 'release' || github.event_name == 'workflow_dispatch' }}
    env:
      TAG_NAME: ${{ github.event.release.tag_name || github.ref_name }}
    permissions:
      contents: write
      packages: read
    outputs:
      pkg_version: ${{ steps.version.outputs.version }}
      release_artifact_name: ${{ steps.package_release.outputs.zip_name }}
      release_zip: ${{ steps.package_release.outputs.zip_name }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ env.TAG_NAME || 'main' }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git safe directory
        run: git config --global --add safe.directory "$GITHUB_WORKSPACE"

      - name: Determine tag version
        id: version
        run: |
          TAG="${TAG_NAME}"
          CLEAN="${TAG#v}"
          echo "version=$CLEAN" >> "$GITHUB_OUTPUT"
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"

      - name: Determine previous tag
        id: previous
        env:
          CURRENT_VERSION: ${{ steps.version.outputs.version }}
          CURRENT_TAG: ${{ steps.version.outputs.tag }}
        run: |
          node <<'NODE'
          import { execSync } from 'node:child_process';
          import { writeFileSync } from 'node:fs';

          const currentVersion = process.env.CURRENT_VERSION;
          const currentTag = process.env.CURRENT_TAG;

          if (!currentVersion || !currentTag) {
            console.error('Missing current version/tag context');
            process.exit(1);
          }

          const toSemver = (value) => {
            const cleaned = value.startsWith('v') ? value.slice(1) : value;
            const parts = cleaned.split('.').map((n) => Number.parseInt(n, 10));
            if (parts.length !== 3 || parts.some(Number.isNaN)) return null;
            return { cleaned, parts };
          };

          const dedupe = new Map();
          const rawTags = execSync('git tag --sort=version:refname', { encoding: 'utf8' })
            .split('\n')
            .map((tag) => tag.trim())
            .filter(Boolean);

          for (const raw of rawTags) {
            const info = toSemver(raw);
            if (!info) continue;
            if (!dedupe.has(info.cleaned)) dedupe.set(info.cleaned, new Set());
            dedupe.get(info.cleaned).add(raw);
          }

          if (!dedupe.has(currentVersion)) {
            console.error(`Current version ${currentVersion} not found among tags`);
            process.exit(1);
          }

          const compare = (a, b) => {
            for (let i = 0; i < 3; i += 1) {
              if (a.parts[i] !== b.parts[i]) return a.parts[i] - b.parts[i];
            }
            return 0;
          };

          const ordered = Array.from(dedupe.keys())
            .map((cleaned) => ({
              cleaned,
              parts: cleaned.split('.').map((n) => Number.parseInt(n, 10)),
            }))
            .filter((info) => info.parts.length === 3 && !info.parts.some(Number.isNaN))
            .sort(compare);

          const currentIndex = ordered.findIndex((info) => info.cleaned === currentVersion);
          const previousInfo = currentIndex > 0 ? ordered[currentIndex - 1] : null;

          const outputLines = [];

          if (previousInfo) {
            const candidates = Array.from(dedupe.get(previousInfo.cleaned));
            const preferred = currentTag.startsWith('v')
              ? candidates.find((tag) => tag.startsWith('v')) || candidates[0]
              : candidates.find((tag) => !tag.startsWith('v')) || candidates[0];

            outputLines.push(`version=${previousInfo.cleaned}`);
            outputLines.push(`tag=${preferred}`);
          } else {
            outputLines.push('version=');
            outputLines.push('tag=');
          }

          writeFileSync(process.env.GITHUB_OUTPUT, `${outputLines.join('\n')}\n`, { flag: 'a' });
          NODE

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Run release:prepare
        env:
          PREVIOUS_TAG: ${{ steps.previous.outputs.tag }}
        run: bun run release:prepare -- ${{ steps.version.outputs.version }}

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Commit and push release preparation changes
        run: |
          git add package.json bun.lock packages/*/package.json CHANGES.md
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "chore: prepare release ${{ steps.version.outputs.version }}"
            git push origin HEAD:main
          fi

      - name: Build workspace
        run: bun run build

      - name: Copy only required .bun packages
        run: |
          cd packages/sidflow-web/.next/standalone
          
          # Find which .bun packages are actually referenced by symlinks
          required_packages=$(find node_modules -type l -exec readlink {} \; | grep "^\.bun" | cut -d/ -f2 | sort -u || true)
          
          if [ -n "$required_packages" ]; then
            echo "Required .bun packages:"
            echo "$required_packages"
            
            # Copy only the required packages to a temporary location
            mkdir -p /tmp/bun-packages
            cd node_modules/.bun
            for pkg in $required_packages; do
              if [ -d "$pkg" ]; then
                size=$(du -sh "$pkg" | cut -f1)
                echo "Copying $pkg ($size)..."
                cp -r "$pkg" /tmp/bun-packages/
              fi
            done
            
            # Remove the full .bun directory and replace with minimal version
            cd ..
            rm -rf .bun
            mkdir .bun
            mv /tmp/bun-packages/* .bun/
            
            echo "Reduced .bun directory size:"
            du -sh .bun
          else
            echo "No .bun packages required"
          fi

      - name: Verify package contents
        run: bun run check:packages --source local

      - name: Extract changelog entry
        id: changelog
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          set -euo pipefail
          ENTRY_DELIM="EOF_CHANGELOG"
          ENTRY_CONTENT="$(bun run --silent changes:entry "${VERSION}" || true)"
          {
            echo "entry<<${ENTRY_DELIM}"
            if [ -n "${ENTRY_CONTENT}" ]; then
              echo "${ENTRY_CONTENT}"
            else
              echo "No changelog entry found for ${VERSION}."
            fi
            echo "${ENTRY_DELIM}"
          } >> "$GITHUB_OUTPUT"

      - name: Format release notes
        id: notes
        env:
          CHANGELOG_ENTRY: ${{ steps.changelog.outputs.entry }}
          CURRENT_TAG: ${{ steps.version.outputs.tag }}
          PREVIOUS_TAG: ${{ steps.previous.outputs.tag }}
        run: |
          node <<'NODE'
          import { writeFileSync } from 'node:fs';

          const changelogEntry = process.env.CHANGELOG_ENTRY || '';
          const previousTag = process.env.PREVIOUS_TAG;
          const currentTag = process.env.CURRENT_TAG;

          const lines = changelogEntry.split('\n');
          const bodyLines = [];

          if (lines.length > 0 && /^##\s+/.test(lines[0])) {
            lines.shift();
          }

          while (lines.length > 0 && lines[0].trim() === '') {
            lines.shift();
          }

          bodyLines.push('## What\'s Changed');
          bodyLines.push('');
          bodyLines.push(lines.join('\n').trim() || '- No notable changes in this release.');

          if (previousTag) {
            bodyLines.push('');
            bodyLines.push(`**Full Changelog**: https://github.com/${process.env.GITHUB_REPOSITORY}/compare/${previousTag}...${currentTag}`);
          }

          const outputFile = process.env.GITHUB_OUTPUT;
          if (!outputFile) {
            console.error('GITHUB_OUTPUT is not set; cannot export release notes.');
            process.exit(1);
          }

          const body = bodyLines.join('\n').replace(/\n{3,}/g, '\n\n');
          const delimiter = 'EOF_RELEASE_BODY';
          writeFileSync(outputFile, `body<<${delimiter}\n${body}\n${delimiter}\n`, { flag: 'a' });
          NODE

      - name: Update GitHub release notes
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RELEASE_BODY: ${{ steps.notes.outputs.body }}
          RELEASE_TAG: ${{ github.ref_name }}
        run: |
          node <<'NODE'
          import process from 'node:process';

          const token = process.env.GH_TOKEN;
          const body = process.env.RELEASE_BODY ?? '';
          const tag = process.env.RELEASE_TAG;
          const repository = process.env.GITHUB_REPOSITORY;

          if (!token) {
            console.error('GH_TOKEN not available; cannot update release notes.');
            process.exit(1);
          }

          if (!repository) {
            console.error('GITHUB_REPOSITORY not set.');
            process.exit(1);
          }

          if (!tag) {
            console.error('Release tag missing.');
            process.exit(1);
          }

          const headers = {
            Authorization: `Bearer ${token}`,
            Accept: 'application/vnd.github+json',
            'X-GitHub-Api-Version': '2022-11-28',
          };

          const apiBase = `https://api.github.com/repos/${repository}/releases`;

          async function fetchJson(url, options) {
            const response = await fetch(url, options);
            if (response.status === 204) {
              return null;
            }
            const text = await response.text();
            let json;
            try {
              json = text ? JSON.parse(text) : null;
            } catch (error) {
              console.error('Failed to parse GitHub API response:', text);
              throw error;
            }
            return { response, json };
          }

          async function main() {
            const tagUrl = `${apiBase}/tags/${encodeURIComponent(tag)}`;
            try {
              const existing = await fetchJson(tagUrl, { headers });
              if (!existing || existing.response.status === 404) {
                const createRes = await fetch(`${apiBase}`, {
                  method: 'POST',
                  headers: {
                    ...headers,
                    'Content-Type': 'application/json',
                  },
                  body: JSON.stringify({
                    tag_name: tag,
                    name: tag,
                    body,
                    draft: false,
                    prerelease: false,
                  }),
                });

                if (!createRes.ok) {
                  const details = await createRes.text();
                  console.error('Failed to create release:', createRes.status, details);
                  process.exit(1);
                }
                console.log(`Created release ${tag} with updated notes.`);
                return;
              }

              if (!existing.response.ok) {
                console.error('Failed to load release:', existing.response.status, existing.json);
                process.exit(1);
              }

              const releaseId = existing.json.id;
              const patchRes = await fetch(`${apiBase}/${releaseId}`, {
                method: 'PATCH',
                headers: {
                  ...headers,
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({ body }),
              });

              if (!patchRes.ok) {
                const details = await patchRes.text();
                console.error('Failed to update release notes:', patchRes.status, details);
                process.exit(1);
              }

              console.log(`Updated release ${tag} notes successfully.`);
            } catch (error) {
              console.error('Error while updating release notes:', error);
              process.exit(1);
            }
          }

          main().catch((error) => {
            console.error('Unexpected error while updating release notes:', error);
            process.exit(1);
          });
          NODE

      - name: Package release artifact
        id: package_release
        env:
          VERSION: ${{ steps.version.outputs.version }}
          SRC_DIR: ${{ github.workspace }}
        run: |
          set -euxo pipefail
          ARCHIVE_NAME="sidflow-${VERSION}"
          ZIP_NAME="${ARCHIVE_NAME}.zip"
          ZIP_PATH="${GITHUB_WORKSPACE}/${ZIP_NAME}"
          export SRC_DIR ARCHIVE_NAME ZIP_PATH
          echo "Filesystem usage before packaging:"
          df -h .
          python3 scripts/ci/package-release.py
          echo "Created zip: ${ZIP_PATH}"
          ls -lh "${ZIP_PATH}"
          echo "Filesystem usage after packaging:"
          df -h .
          {
            echo "ZIP_NAME=${ZIP_NAME}"
            echo "ZIP_PATH=${ZIP_PATH}"
            echo "TARGET_DIR=${ARCHIVE_NAME}"
          } >> "$GITHUB_ENV"
          ZIP_NAME="${ARCHIVE_NAME}.zip"
          echo "zip_name=${ZIP_NAME}" >> "$GITHUB_OUTPUT"
          echo "zip_path=${ZIP_PATH}" >> "$GITHUB_OUTPUT"

      - name: Upload release artifact (zip)
        id: upload_release_artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.package_release.outputs.zip_name }}
          path: ${{ steps.package_release.outputs.zip_path }}
          if-no-files-found: error
          retention-days: 7

      - name: Attach zip to GitHub release
        uses: softprops/action-gh-release@v2
        with:
          files: ${{ steps.package_release.outputs.zip_path }}
          fail_on_unmatched_files: true

  smoke_test_release:
    needs: release
    runs-on: ubuntu-latest

    steps:
      - name: Download release artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.release.outputs.release_artifact_name }}
          path: extracted

      - name: Extract release zip
        working-directory: extracted
        env:
          ZIP_NAME: ${{ needs.release.outputs.release_artifact_name }}
        run: |
          set -euxo pipefail
          unzip -q "${ZIP_NAME}" -d .

      - name: Start packaged server
        working-directory: extracted
        env:
          VERSION: ${{ needs.release.outputs.pkg_version }}
        run: |
          set -euxo pipefail
          RELEASE_DIR="sidflow-${VERSION}"
          cd "${RELEASE_DIR}"
          export SIDFLOW_ADMIN_USER=admin
          export SIDFLOW_ADMIN_PASSWORD=release-smoke-secret
          ./scripts/start-release-server.sh >"${RUNNER_TEMP}/release.log" 2>&1 &
          echo $! > "${RUNNER_TEMP}/release.pid"
          # Wait for server to become healthy (max 10s)
          for i in {1..10}; do
            if curl -sf http://127.0.0.1:3000/api/health > /dev/null; then
              echo "Server is healthy after ${i} seconds"
              break
            fi
            sleep 1
          done

          # Verify server health after wait loop
          if ! curl -sf http://127.0.0.1:3000/api/health > /dev/null; then
            echo "ERROR: Server did not become healthy after 10 seconds" >&2
            echo "Last 50 lines of server log:" >&2
            tail -n 50 "${RUNNER_TEMP}/release.log" >&2
            exit 1
          fi
      - name: Smoke test /api/health
        run: |
          # Test health endpoint and verify JSON response
          RESPONSE=$(curl -f --retry 5 --retry-delay 5 http://127.0.0.1:3000/api/health)
          echo "Health check response: ${RESPONSE}"
          
          # Verify response contains expected fields
          if ! echo "${RESPONSE}" | grep -q '"overall"'; then
            echo "ERROR: Health response missing 'overall' field" >&2
            exit 1
          fi
          
          if ! echo "${RESPONSE}" | grep -q '"timestamp"'; then
            echo "ERROR: Health response missing 'timestamp' field" >&2
            exit 1
          fi

      - name: Stop server
        if: always()
        run: |
          if [ -f "${RUNNER_TEMP}/release.pid" ]; then
            kill "$(cat "${RUNNER_TEMP}/release.pid")" || true
          fi

      - name: Upload release server logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: release-smoke-logs
          path: ${{ runner.temp }}/release.log
          if-no-files-found: ignore
