name: Release Packages

on:
  push:
    tags:
      - "*.*.*"
      - "v*.*.*"
  release:
    types: [published]
  workflow_dispatch:

jobs:
  release:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/${{ github.repository_owner }}/sidflow-ci:latest
    if: ${{ github.ref_type == 'tag' || github.event_name == 'release' || github.event_name == 'workflow_dispatch' }}
    env:
      TAG_NAME: ${{ github.event.release.tag_name || github.ref_name }}
    permissions:
      contents: write
      packages: read
    outputs:
      pkg_version: ${{ steps.version.outputs.version }}
      release_tag: ${{ steps.version.outputs.tag }}
      release_artifact_name: ${{ steps.package_release.outputs.zip_name }}
      release_zip: ${{ steps.package_release.outputs.zip_name }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ env.TAG_NAME || 'main' }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git safe directory
        run: git config --global --add safe.directory "$GITHUB_WORKSPACE"

      - name: Determine tag version
        id: version
        run: |
          TAG="${TAG_NAME}"
          CLEAN="${TAG#v}"
          echo "version=$CLEAN" >> "$GITHUB_OUTPUT"
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"

      - name: Determine previous tag
        id: previous
        env:
          CURRENT_VERSION: ${{ steps.version.outputs.version }}
          CURRENT_TAG: ${{ steps.version.outputs.tag }}
        run: |
          node <<'NODE'
          import { execSync } from 'node:child_process';
          import { writeFileSync } from 'node:fs';

          const currentVersion = process.env.CURRENT_VERSION;
          const currentTag = process.env.CURRENT_TAG;

          if (!currentVersion || !currentTag) {
            console.error('Missing current version/tag context');
            process.exit(1);
          }

          const toSemver = (value) => {
            const cleaned = value.startsWith('v') ? value.slice(1) : value;
            const parts = cleaned.split('.').map((n) => Number.parseInt(n, 10));
            if (parts.length !== 3 || parts.some(Number.isNaN)) return null;
            return { cleaned, parts };
          };

          const dedupe = new Map();
          const rawTags = execSync('git tag --sort=version:refname', { encoding: 'utf8' })
            .split('\n')
            .map((tag) => tag.trim())
            .filter(Boolean);

          for (const raw of rawTags) {
            const info = toSemver(raw);
            if (!info) continue;
            if (!dedupe.has(info.cleaned)) dedupe.set(info.cleaned, new Set());
            dedupe.get(info.cleaned).add(raw);
          }

          if (!dedupe.has(currentVersion)) {
            console.error(`Current version ${currentVersion} not found among tags`);
            process.exit(1);
          }

          const compare = (a, b) => {
            for (let i = 0; i < 3; i += 1) {
              if (a.parts[i] !== b.parts[i]) return a.parts[i] - b.parts[i];
            }
            return 0;
          };

          const ordered = Array.from(dedupe.keys())
            .map((cleaned) => ({
              cleaned,
              parts: cleaned.split('.').map((n) => Number.parseInt(n, 10)),
            }))
            .filter((info) => info.parts.length === 3 && !info.parts.some(Number.isNaN))
            .sort(compare);

          const currentIndex = ordered.findIndex((info) => info.cleaned === currentVersion);
          const previousInfo = currentIndex > 0 ? ordered[currentIndex - 1] : null;

          const outputLines = [];

          if (previousInfo) {
            const candidates = Array.from(dedupe.get(previousInfo.cleaned));
            const preferred = currentTag.startsWith('v')
              ? candidates.find((tag) => tag.startsWith('v')) || candidates[0]
              : candidates.find((tag) => !tag.startsWith('v')) || candidates[0];

            outputLines.push(`version=${previousInfo.cleaned}`);
            outputLines.push(`tag=${preferred}`);
          } else {
            outputLines.push('version=');
            outputLines.push('tag=');
          }

          writeFileSync(process.env.GITHUB_OUTPUT, `${outputLines.join('\n')}\n`, { flag: 'a' });
          NODE

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Run release:prepare
        env:
          PREVIOUS_TAG: ${{ steps.previous.outputs.tag }}
        run: bun run release:prepare -- ${{ steps.version.outputs.version }}

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Commit and push release preparation changes
        run: |
          git add package.json bun.lock packages/*/package.json CHANGES.md
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "chore: prepare release ${{ steps.version.outputs.version }}"
            git push origin HEAD:main
          fi

      - name: Build workspace
        run: bun run build

      - name: Build Next.js standalone
        run: |
          cd packages/sidflow-web
          bun run build:worklet
          bun run build

      - name: Copy static assets into standalone
        run: |
          set -euxo pipefail
          cd packages/sidflow-web
          STANDALONE_ROOT=".next/standalone/packages/sidflow-web"
          
          # Copy public directory into standalone root
          if [ -d "public" ]; then
            echo "Copying public/ to ${STANDALONE_ROOT}/public"
            cp -r public "${STANDALONE_ROOT}/"
          fi
          
          # Copy .next/static into standalone .next/
          if [ -d ".next/static" ]; then
            echo "Copying .next/static to ${STANDALONE_ROOT}/.next/static"
            mkdir -p "${STANDALONE_ROOT}/.next"
            cp -r .next/static "${STANDALONE_ROOT}/.next/"
          fi
          
          echo "Standalone tree structure:"
          find "${STANDALONE_ROOT}" -maxdepth 2 -type d | sort

      - name: Install production dependencies for standalone
        run: |
          cd packages/sidflow-web/.next/standalone/packages/sidflow-web
          # Copy package.json from source (use relative path from repo root)
          cp ../../../../package.json .
          # Install only production dependencies
          bun install --production --no-save
          # Clean up package.json copy
          rm package.json

      - name: Verify package contents
        run: bun run check:packages --source local

      - name: Extract changelog entry
        id: changelog
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          set -euo pipefail
          ENTRY_DELIM="EOF_CHANGELOG"
          ENTRY_CONTENT="$(bun run --silent changes:entry "${VERSION}" || true)"
          {
            echo "entry<<${ENTRY_DELIM}"
            if [ -n "${ENTRY_CONTENT}" ]; then
              echo "${ENTRY_CONTENT}"
            else
              echo "No changelog entry found for ${VERSION}."
            fi
            echo "${ENTRY_DELIM}"
          } >> "$GITHUB_OUTPUT"

      - name: Format release notes
        id: notes
        env:
          CHANGELOG_ENTRY: ${{ steps.changelog.outputs.entry }}
          CURRENT_TAG: ${{ steps.version.outputs.tag }}
          PREVIOUS_TAG: ${{ steps.previous.outputs.tag }}
        run: |
          node <<'NODE'
          import { writeFileSync } from 'node:fs';

          const changelogEntry = process.env.CHANGELOG_ENTRY || '';
          const previousTag = process.env.PREVIOUS_TAG;
          const currentTag = process.env.CURRENT_TAG;

          const lines = changelogEntry.split('\n');
          const bodyLines = [];

          if (lines.length > 0 && /^##\s+/.test(lines[0])) {
            lines.shift();
          }

          while (lines.length > 0 && lines[0].trim() === '') {
            lines.shift();
          }

          bodyLines.push('## What\'s Changed');
          bodyLines.push('');
          bodyLines.push(lines.join('\n').trim() || '- No notable changes in this release.');

          if (previousTag) {
            bodyLines.push('');
            bodyLines.push(`**Full Changelog**: https://github.com/${process.env.GITHUB_REPOSITORY}/compare/${previousTag}...${currentTag}`);
          }

          const outputFile = process.env.GITHUB_OUTPUT;
          if (!outputFile) {
            console.error('GITHUB_OUTPUT is not set; cannot export release notes.');
            process.exit(1);
          }

          const body = bodyLines.join('\n').replace(/\n{3,}/g, '\n\n');
          const delimiter = 'EOF_RELEASE_BODY';
          writeFileSync(outputFile, `body<<${delimiter}\n${body}\n${delimiter}\n`, { flag: 'a' });
          NODE

      - name: Update GitHub release notes
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RELEASE_BODY: ${{ steps.notes.outputs.body }}
          RELEASE_TAG: ${{ github.ref_name }}
        run: |
          node <<'NODE'
          import process from 'node:process';

          const token = process.env.GH_TOKEN;
          const body = process.env.RELEASE_BODY ?? '';
          const tag = process.env.RELEASE_TAG;
          const repository = process.env.GITHUB_REPOSITORY;

          if (!token) {
            console.error('GH_TOKEN not available; cannot update release notes.');
            process.exit(1);
          }

          if (!repository) {
            console.error('GITHUB_REPOSITORY not set.');
            process.exit(1);
          }

          if (!tag) {
            console.error('Release tag missing.');
            process.exit(1);
          }

          const headers = {
            Authorization: `Bearer ${token}`,
            Accept: 'application/vnd.github+json',
            'X-GitHub-Api-Version': '2022-11-28',
          };

          const apiBase = `https://api.github.com/repos/${repository}/releases`;

          async function fetchJson(url, options) {
            const response = await fetch(url, options);
            if (response.status === 204) {
              return null;
            }
            const text = await response.text();
            let json;
            try {
              json = text ? JSON.parse(text) : null;
            } catch (error) {
              console.error('Failed to parse GitHub API response:', text);
              throw error;
            }
            return { response, json };
          }

          async function main() {
            const tagUrl = `${apiBase}/tags/${encodeURIComponent(tag)}`;
            try {
              const existing = await fetchJson(tagUrl, { headers });
              if (!existing || existing.response.status === 404) {
                const createRes = await fetch(`${apiBase}`, {
                  method: 'POST',
                  headers: {
                    ...headers,
                    'Content-Type': 'application/json',
                  },
                  body: JSON.stringify({
                    tag_name: tag,
                    name: tag,
                    body,
                    draft: false,
                    prerelease: false,
                  }),
                });

                if (!createRes.ok) {
                  const details = await createRes.text();
                  console.error('Failed to create release:', createRes.status, details);
                  process.exit(1);
                }
                console.log(`Created release ${tag} with updated notes.`);
                return;
              }

              if (!existing.response.ok) {
                console.error('Failed to load release:', existing.response.status, existing.json);
                process.exit(1);
              }

              const releaseId = existing.json.id;
              const patchRes = await fetch(`${apiBase}/${releaseId}`, {
                method: 'PATCH',
                headers: {
                  ...headers,
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({ body }),
              });

              if (!patchRes.ok) {
                const details = await patchRes.text();
                console.error('Failed to update release notes:', patchRes.status, details);
                process.exit(1);
              }

              console.log(`Updated release ${tag} notes successfully.`);
            } catch (error) {
              console.error('Error while updating release notes:', error);
              process.exit(1);
            }
          }

          main().catch((error) => {
            console.error('Unexpected error while updating release notes:', error);
            process.exit(1);
          });
          NODE

      - name: Package release artifact
        id: package_release
        env:
          VERSION: ${{ steps.version.outputs.version }}
          SRC_DIR: ${{ github.workspace }}
        run: |
          set -euxo pipefail
          ARCHIVE_NAME="sidflow-${VERSION}"
          ZIP_NAME="${ARCHIVE_NAME}.zip"
          ZIP_PATH="${GITHUB_WORKSPACE}/${ZIP_NAME}"
          export SRC_DIR ARCHIVE_NAME ZIP_PATH
          echo "Filesystem usage before packaging:"
          df -h .
          python3 scripts/ci/package-release.py
          echo "Created zip: ${ZIP_PATH}"
          ls -lh "${ZIP_PATH}"
          echo "Filesystem usage after packaging:"
          df -h .
          {
            echo "ZIP_NAME=${ZIP_NAME}"
            echo "ZIP_PATH=${ZIP_PATH}"
            echo "TARGET_DIR=${ARCHIVE_NAME}"
          } >> "$GITHUB_ENV"
          ZIP_NAME="${ARCHIVE_NAME}.zip"
          echo "zip_name=${ZIP_NAME}" >> "$GITHUB_OUTPUT"
          echo "zip_path=${ZIP_PATH}" >> "$GITHUB_OUTPUT"

      - name: Upload release artifact (zip)
        id: upload_release_artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.package_release.outputs.zip_name }}
          path: ${{ steps.package_release.outputs.zip_path }}
          if-no-files-found: error
          retention-days: 7

      - name: Attach zip to GitHub release
        uses: softprops/action-gh-release@v2
        with:
          files: ${{ steps.package_release.outputs.zip_path }}
          fail_on_unmatched_files: true

  build_docker_image:
    needs: release
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      image_tag: ${{ steps.meta.outputs.tags }}
      image_digest: ${{ steps.build.outputs.digest }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ needs.release.outputs.release_tag || github.ref || 'main' }}

      - name: Set up QEMU for multi-platform builds
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=semver,pattern={{version}},value=${{ needs.release.outputs.pkg_version }}
            type=semver,pattern={{major}}.{{minor}},value=${{ needs.release.outputs.pkg_version }}
            type=semver,pattern={{major}},value=${{ needs.release.outputs.pkg_version }}
            type=raw,value=latest,enable={{is_tag}}
          labels: |
            org.opencontainers.image.title=SIDFlow
            org.opencontainers.image.description=C64 music player with mood-based classification
            org.opencontainers.image.vendor=${{ github.repository_owner }}

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile.production
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          provenance: false

      - name: Set image visibility to public
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euxo pipefail
          PACKAGE_OWNER="${GITHUB_REPOSITORY_OWNER}"
          PACKAGE_NAME="${GITHUB_REPOSITORY#*/}"
          PACKAGE_NAME_LOWER=$(echo "$PACKAGE_NAME" | tr '[:upper:]' '[:lower:]')

          if ! gh api \
            --method PATCH \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/orgs/${PACKAGE_OWNER}/packages/container/${PACKAGE_NAME_LOWER}/visibility" \
            -f visibility=public; then
            gh api \
              --method PATCH \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "/user/packages/container/${PACKAGE_NAME_LOWER}/visibility" \
              -f visibility=public \
              || echo "Note: Set visibility to public manually in GitHub package settings."
          fi

  validate_docker_image:
    needs: build_docker_image
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read

    steps:
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull Docker image
        run: |
          # Extract the first tag (should be the versioned tag)
          IMAGE_TAG=$(echo "${{ needs.build_docker_image.outputs.image_tag }}" | head -n1)
          echo "Pulling image: ${IMAGE_TAG}"
          docker pull "${IMAGE_TAG}"
          echo "IMAGE_TAG=${IMAGE_TAG}" >> "$GITHUB_ENV"

      - name: Start container
        env:
          SIDFLOW_ADMIN_USER: admin
          SIDFLOW_ADMIN_PASSWORD: docker-test-secret
        run: |
          set -euxo pipefail
          
          # Start container in detached mode
          CONTAINER_ID=$(docker run -d \
            -p 3000:3000 \
            -e SIDFLOW_ADMIN_USER="${SIDFLOW_ADMIN_USER}" \
            -e SIDFLOW_ADMIN_PASSWORD="${SIDFLOW_ADMIN_PASSWORD}" \
            -e NODE_ENV=production \
            "${IMAGE_TAG}")
          
          echo "CONTAINER_ID=${CONTAINER_ID}" >> "$GITHUB_ENV"
          echo "Started container: ${CONTAINER_ID}"

      - name: Wait for container health check
        timeout-minutes: 2
        run: |
          set -euxo pipefail
          
          echo "Waiting for container to become healthy..."
          MAX_ATTEMPTS=60
          ATTEMPT=0
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            HEALTH_STATUS=$(docker inspect --format='{{.State.Health.Status}}' "${CONTAINER_ID}" 2>/dev/null || echo "unknown")
            
            echo "Attempt $((ATTEMPT + 1))/${MAX_ATTEMPTS}: Health status = ${HEALTH_STATUS}"
            
            if [ "${HEALTH_STATUS}" = "healthy" ]; then
              echo "✓ Container is healthy!"
              exit 0
            elif [ "${HEALTH_STATUS}" = "unhealthy" ]; then
              echo "✗ Container became unhealthy"
              docker logs "${CONTAINER_ID}" || true
              exit 1
            fi
            
            sleep 2
            ATTEMPT=$((ATTEMPT + 1))
          done
          
          echo "✗ Container did not become healthy within timeout"
          docker logs "${CONTAINER_ID}" || true
          exit 1

      - name: Test health endpoint
        run: |
          # Test the health endpoint directly
          RESPONSE=$(curl -f http://localhost:3000/api/health)
          echo "Health check response: ${RESPONSE}"
          
          # Verify response structure
          if ! echo "${RESPONSE}" | grep -q '"overall"'; then
            echo "ERROR: Health response missing 'overall' field" >&2
            exit 1
          fi
          
          if ! echo "${RESPONSE}" | grep -q '"timestamp"'; then
            echo "ERROR: Health response missing 'timestamp' field" >&2
            exit 1
          fi
          
          echo "✓ Health endpoint validation passed"

      - name: Stop and remove container
        if: always()
        run: |
          if [ -n "${CONTAINER_ID:-}" ]; then
            echo "Stopping container: ${CONTAINER_ID}"
            docker stop "${CONTAINER_ID}" || true
            docker rm "${CONTAINER_ID}" || true
          fi

      - name: Upload container logs
        if: always()
        run: |
          if [ -n "${CONTAINER_ID:-}" ]; then
            docker logs "${CONTAINER_ID}" > container.log 2>&1 || true
          fi

      - name: Upload logs artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: docker-validation-logs
          path: container.log
          if-no-files-found: ignore

  smoke_test_release:
    needs: release
    runs-on: ubuntu-latest

    steps:
      - name: Download release artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.release.outputs.release_artifact_name }}
          path: extracted

      - name: Extract release zip
        working-directory: extracted
        env:
          ZIP_NAME: ${{ needs.release.outputs.release_artifact_name }}
        run: |
          set -euxo pipefail
          unzip -q "${ZIP_NAME}" -d .

      - name: Start packaged server
        working-directory: extracted
        env:
          VERSION: ${{ needs.release.outputs.pkg_version }}
        run: |
          set -euxo pipefail
          RELEASE_DIR="sidflow-${VERSION}"
          cd "${RELEASE_DIR}"
          export SIDFLOW_ADMIN_USER=admin
          export SIDFLOW_ADMIN_PASSWORD=release-smoke-secret
          ./scripts/start-release-server.sh >"${RUNNER_TEMP}/release.log" 2>&1 &
          echo $! > "${RUNNER_TEMP}/release.pid"
          # Wait for server to become healthy (max 10s)
          for i in {1..10}; do
            if curl -sf http://127.0.0.1:3000/api/health > /dev/null; then
              echo "Server is healthy after ${i} seconds"
              break
            fi
            sleep 1
          done

          # Verify server health after wait loop
          if ! curl -sf http://127.0.0.1:3000/api/health > /dev/null; then
            echo "ERROR: Server did not become healthy after 10 seconds" >&2
            echo "Last 50 lines of server log:" >&2
            tail -n 50 "${RUNNER_TEMP}/release.log" >&2
            exit 1
          fi
      - name: Smoke test /api/health
        run: |
          # Test health endpoint and verify JSON response
          RESPONSE=$(curl -f --retry 5 --retry-delay 5 http://127.0.0.1:3000/api/health)
          echo "Health check response: ${RESPONSE}"
          
          # Verify response contains expected fields
          if ! echo "${RESPONSE}" | grep -q '"overall"'; then
            echo "ERROR: Health response missing 'overall' field" >&2
            exit 1
          fi
          
          if ! echo "${RESPONSE}" | grep -q '"timestamp"'; then
            echo "ERROR: Health response missing 'timestamp' field" >&2
            exit 1
          fi

      - name: Stop server
        if: always()
        run: |
          if [ -f "${RUNNER_TEMP}/release.pid" ]; then
            kill "$(cat "${RUNNER_TEMP}/release.pid")" || true
          fi

      - name: Upload release server logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: release-smoke-logs
          path: ${{ runner.temp }}/release.log
          if-no-files-found: ignore
